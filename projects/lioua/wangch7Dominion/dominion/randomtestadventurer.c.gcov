        -:    0:Source:randomtestadventurer.c
        -:    0:Graph:randomtestadventurer.gcno
        -:    0:Data:randomtestadventurer.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:/* Card Test Random: Adventurer Card
        -:    2: *  Card test/random test for the Adventurer Card
        -:    3: *  Card Effect: Reveal cards from deck until 2 treasure is revealed, add the treasure cards to hand, discard the revealed cards.
        -:    4: * 
        -:    5: * randomtestadventurer: randomtestadventurer.c dominion.o rngs.o
        -:    6: * gcc -o randomtestadventurer -g  randomtestadventurer.c dominion.o rngs.o $(CFLAGS)
        -:    7: */
        -:    8:#include "dominion.h"
        -:    9:#include "dominion_helpers.h"
        -:   10:#include <string.h>
        -:   11:#include <stdio.h>
        -:   12:#include <assert.h>
        -:   13:#include "rngs.h"
        -:   14:#include <stdlib.h>
        -:   15:#include <math.h>
        -:   16:#include <time.h>
        -:   17:
        -:   18:#define TESTCARD "adventurer"
        -:   19:
function main called 2 returned 100% blocks executed 92%
        -:   20:int main() {
        2:   21:    int pass = 1;
        -:   22:    struct gameState G, testState;
        -:   23:    // int k[10] = {
        -:   24:    //     adventurer, council_room, feast, gardens, mine, remodel, smithy, village, baron, great_hall
        -:   25:    // };
        -:   26:
        2:   27:    int x = 1000;
        -:   28:    int i, n, r, playedCard;
        2:   29:    int handPos = 0, choice1 = 0, choice2 = 0, choice3 = 0, bonus = 0;
        -:   30:    int thisPlayer;
        2:   31:    int addedCards = 2;
        -:   32:    int coin, expectedCoin;
        -:   33:    int totalCards, expectedCards;
        -:   34:
        -:   35:    //initialize game state
        -:   36:    //initializeGame(numbPlayers, k, randSeed, &G);
        -:   37:
        -:   38:    //initialize random
        2:   39:    srand(time(NULL));
        2:   40:	printf("Random Testing for Card: Adventurer\n");
     4004:   41:    for (i = 0; i < x; i++){
branch  0 taken 99%
branch  1 taken 1%
     2000:   42:        printf("\nTest Case: %d\n", i);
 26304000:   43:        for (n = 0; n < sizeof(struct gameState) / sizeof(int); n++) {
branch  0 taken 99%
branch  1 taken 1%
 13150000:   44:            ((int*)&G)[n] = rand() % 128;
 13150000:   45:        }
        -:   46:
     2000:   47:        G.numPlayers = (rand() % 3)+2;
     2000:   48:        G.whoseTurn = rand() % G.numPlayers;
     2000:   49:        thisPlayer = whoseTurn(&G);
     2000:   50:        G.handCount[thisPlayer] = (rand() % (MAX_HAND/2))+1;
     2000:   51:        G.deckCount[thisPlayer] = (rand() % (MAX_DECK/2))+1;
     2000:   52:        G.discardCount[thisPlayer] = (rand() % (MAX_DECK/2))+1;
     2000:   53:        handPos = (rand() % G.handCount[thisPlayer]);
   511406:   54:        for (n = 0; n < G.handCount[thisPlayer]; n++) {
branch  0 taken 99%
branch  1 taken 1%
   253703:   55:            r = (rand() % 2);
   253703:   56:            if (r == 0) {
branch  0 taken 50%
branch  1 taken 50%
   126812:   57:                G.hand[thisPlayer][n] = copper;
   126812:   58:            } else {
   126891:   59:                G.hand[thisPlayer][n] = estate;
        -:   60:            }
   253703:   61:        }
   506016:   62:        for (n = 0; n < G.deckCount[thisPlayer]; n++) {
branch  0 taken 99%
branch  1 taken 1%
   251008:   63:            r = (rand() % 2);
   251008:   64:            if (r == 0) {
branch  0 taken 50%
branch  1 taken 50%
   125916:   65:                G.deck[thisPlayer][n] = copper;
   125916:   66:            } else {
   125092:   67:                G.deck[thisPlayer][n] = estate;
        -:   68:            }
   251008:   69:        }
        -:   70:        //Copy game State to Compare
     2000:   71:        memcpy(&testState, &G, sizeof(struct gameState));
        -:   72:
     2000:   73:        playedCard = cardEffect(adventurer, choice1, choice2, choice3, &testState, handPos, &bonus);
        -:   74:        
        -:   75:        //Invalid Return Value        
     2000:   76:        if (playedCard != 0) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   77:            printf("Playing Card Failed");
    #####:   78:            pass = 0;
    #####:   79:        };
        -:   80:        
        -:   81:        //Incorrect hand count
     2000:   82:        if (testState.handCount[thisPlayer] != G.handCount[thisPlayer]+addedCards){
branch  0 taken 1%
branch  1 taken 99%
        3:   83:            pass = 0;
        3:   84:            printf("Hand Count: %d, Expected: %d \n\n", testState.handCount[thisPlayer], G.handCount[thisPlayer]+addedCards);
        3:   85:        }
        -:   86:
     2000:   87:        totalCards = G.deckCount[thisPlayer] + G.discardCount[thisPlayer];
     2000:   88:        expectedCards = testState.deckCount[thisPlayer] + testState.discardCount[thisPlayer];
     2000:   89:        if (expectedCards != totalCards - addedCards) {
branch  0 taken 1%
branch  1 taken 99%
        3:   90:            pass = 0;
        3:   91:            printf("Total Cards: %d, Expected: %d \n\n", expectedCards, totalCards-addedCards);
        3:   92:        };
        -:   93:
     2000:   94:        coin = 0;
     2000:   95:        n = 0;
   511406:   96:        while (n < numHandCards(&G)) {
branch  0 taken 99%
branch  1 taken 1%
   253703:   97:            if (handCard(n, &G) == copper) {
branch  0 taken 50%
branch  1 taken 50%
   126812:   98:                coin++;
   253703:   99:            } else if (handCard(n, &G) == silver) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  100:                coin += 2;
   126891:  101:            } else if (handCard(n, &G) == gold) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  102:                coin += 3;
    #####:  103:            }
   253703:  104:            n++;
        -:  105:        }
        -:  106:
     2000:  107:        expectedCoin = 0;
     2000:  108:        n = 0;
   519390:  109:        while (n < numHandCards(&testState)) {
branch  0 taken 99%
branch  1 taken 1%
   257695:  110:            if (handCard(n, &testState) == copper) {
branch  0 taken 51%
branch  1 taken 49%
   130793:  111:                expectedCoin++;
   257695:  112:            } else if (handCard(n, &testState) == silver) {
branch  0 taken 1%
branch  1 taken 99%
        8:  113:                expectedCoin += 2;
   126902:  114:            } else if (handCard(n, &testState) == gold) {
branch  0 taken 1%
branch  1 taken 99%
        7:  115:                expectedCoin += 3;
        7:  116:            }
   257695:  117:            n++;
        -:  118:        };
     2000:  119:        if (expectedCoin < coin + 2) {
branch  0 taken 1%
branch  1 taken 99%
        2:  120:            pass = 0;
        2:  121:            printf("Coin Count: %d, Expected Coin Count: >= %d \n\n", expectedCoin, coin + 2);
        2:  122:        }
     2000:  123:    }
        -:  124:    //End For Loop and Return Results
        2:  125:    if (pass) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  126:        printf(">>>>>TEST SUCCESSFULLY COMPLETED <<<<<\n");
    #####:  127:    } else{
        2:  128:        printf(">>>>>TEST FAILED<<<<<\n");
        -:  129:    }
        2:  130:	printf("\n >>>>> Random Card Test Complete - Adventurer <<<<<\n\n");
        2:  131:    return 0;
        -:  132:}
